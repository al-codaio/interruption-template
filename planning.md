# High-level planning
I want to create an AI application in LangGraph that will dynamically check for required fields in the state object at any node without hardcoding each field check. For example, if a required field (like "user_email" or "document_id") is missing from the state, I want the graph to:
- Automatically interrupt execution
- Show a user-friendly message (e.g., “Please provide your email address”) (detected and generated by the model)
- Update the state and resume the execution from the correct node once the user provides the missing information.

## What to avoid
- Manually hardcoding every possible field check at every node.
- Repeating similar boilerplate across nodes.

## Ideal Scenario
- Each node (or a shared decorator/helper) can declare which fields it needs,
- The check and user-friendly interrupt is generic
- Minimal duplication across nodes

# Architecture
I have a high-level architecture in mind. The core idea is to introduce a validation layer before critical processing in the graph.

## Rich AgentState (Pydantic BaseModel): 
- add missing_fields: List[str] to the state to keep track of what's still needed, and next_node_after_validation: Optional[str] to remember where the graph wanted to go before the interruption.
## process_user_input Node
- This node is responsible for parsing the user's input after an interrupt and updating the AgentState.
- After updating, it routes back to validate_state to re-check if all fields are now present. This creates a loop until all prerequisites are met.
## Centralized NODE_REQUIREMENTS Dictionary
- This will be a simple Python dictionary where keys are your node names (strings) and values are lists of strings representing the required fields from the AgentState for that node to execute.
＃＃validate_state_and_interrupt Node: 
- It's designed to be invoked before any node that requires specific information. 
- This node will now look up the requirements in NODE_REQUIREMENTS based on state.next_node_after_validation.
- takes state.next_node_after_validation and uses it as a key to look up requirements in NODE_REQUIREMENTS.
- interrupt(): This function from langgraph.types is called when missing fields are detected. It pauses the graph execution.
## Routing
- The StateGraph's conditional edges will set state.next_node_after_validation before going to validate_state_and_interrupt.
- something like SomeNode -> Set state.next_node_after_validation -> validate_state -> (Interrupt | ActualProcessingNode)
- After process_user_input, it always loops back to validate_state to re-evaluate the state.
## start_analysis node does the actual work
- this node requires user_email and document_id (as defined in NODE_REQUIREMENTS)
## performs_step_2 node 
- reuqires the analysis_result field (output from the start_analysis node)
- also defined in NODE_REQUIREMENTS
## orchestator node
- A central "orchestrator" node decides the next step based on state
- After orchestrator, always go to validation. The orchestrator should have set state.next_node_after_validation
- I think this node would set the next_node_after_validation used by validate_state_and_interrupt node
## Checkpointers
- You will need to incorporate the checkpointer concept from LangGraph so that conversations between the human and the model are persisted as context in the conversation


# Requirements

## Simplicity
- Keep the app as simple as possible with minimal code
- I want to to be able to publish this repo as a template for others to copy. So I want to keep files short and not have extra code that accounts for random edge cases.
- Try to keep the files flat in the root folder and avoid nesting files in directories

## LangGraph Studio
- I want to be able to launch the LangGraph Studio with langgraph dev and be able to interact with this AI application
- You will most likely need to edit the AgentState and play around with formatting so that in LangGraph Studio you don't have to enter in a json object and can just enter in strings for the human prompt
- You will need to create a langgraph.json file so that the application can be tested in LangGraph Studio

## HTML page with chatbot
- The application also has to have a basic HTML page showing a chatbot where I can interact with the application
- The chatbot would be able to know when an interrupt is happening in the graph and then ask teh user for additional info like email or document ID if these fields have not been provided
- The API endpoint for this application will most likely be /graph/invoke and must be able to be used in LangGraph Studio and in this basic html page

# Next steps
- Create the minimum number of files and minimum lines of code in each file to make this application work.